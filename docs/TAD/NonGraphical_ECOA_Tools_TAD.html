<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ECOA Tools TAD</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="file:css\\markdown10.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">ECOA Tools TAD</h1>
<p>Copyright 2023 Dassault Aviation</p>
<p>MIT License (see LICENSE.txt)</p>
</header>
<h1
id="non-graphical-ecoa-tools-architecture-document-tad">Non-graphical
ECOA Tools Architecture Document (TAD)</h1>
<h2 id="description-of-the-toolkit-software-architecture">1. Description
of the toolkit software architecture</h2>
<h3 id="toolkit-overview">1.1 Toolkit overview</h3>
<p>ECOA tools aim at facilitating ECOA system design and development.
The toolkit of non-graphical tools is composed of five tools : ASCTG,
CSMGVT, EXVT, LDP and MSCIGT.</p>
<p>MSCIGT and CSMGVT rely on a common package called ECOA-TOOLSET,
allowing to manipulate ECOA XML models.</p>
<h3 id="cots">1.2 COTS</h3>
<p>COTS used in all tools : Python3.8, C/C++</p>
<p>COTS used in LDP : Cunit (Unit test), APR (system calls abstraction),
zlog (logging facility), C/C++ (ECOA framework library)</p>
<h3 id="configuration">1.3 Configuration</h3>
<p>All ECOA tools take an ECOA project description file as an input.</p>
<p>Other specific configuration options are available, for example:</p>
<ul>
<li>ASCTG also requires an ECOA configuration file specifying the
components under test.</li>
<li>EXVT can validate ECOA incomplete models, in accordance with the
requested level of the validation (input parameter).</li>
<li>MSCIGT can take an input template, specifying a customized file
header style for code and header files.</li>
</ul>
<p>Please see user documentation of each tool for further details.</p>
<h3 id="global-architecture">1.4 Global architecture</h3>
<h4 id="exvt">1.4.1 EXVT</h4>
<p>EXVT is an ECOA model checker.</p>
<p>The ECOA project validation consists in the following steps:</p>
<ul>
<li>Project XML files parsing (with syntax checks using xsd
validation)</li>
<li>Build of an ECOA model.</li>
<li>Consistency checks of ECOA model.</li>
<li>Syntax checks.</li>
<li>Legality rules checks (ECOA AS6 Part7 Metamodel).</li>
<li>Consistency between ECOA XML files.</li>
<li>Generation of a final report with the status of the validation.</li>
</ul>
<h5 id="class-diagrams">Class diagrams</h5>
<h6 id="types">Types</h6>
<figure>
<img src="images/Figure-02-Internal-Types-Class-Diagram-1.png"
alt="Internal Types Class Diagram 1" />
<figcaption aria-hidden="true">Internal Types Class Diagram
1</figcaption>
</figure>
<figure>
<img src="images/Figure-03-Internal-Types-Class-Diagram-2.png"
alt="Internal Types Class Diagram 2" />
<figcaption aria-hidden="true">Internal Types Class Diagram
2</figcaption>
</figure>
<figure>
<img src="images/Figure-04-Internal-Types-Class-Diagram-3.png"
alt="Internal Types Class Diagram 3" />
<figcaption aria-hidden="true">Internal Types Class Diagram
3</figcaption>
</figure>
<figure>
<img src="images/Figure-05-Internal-Types-Class-Diagram-4.png"
alt="Internal Types Class Diagram 4" />
<figcaption aria-hidden="true">Internal Types Class Diagram
4</figcaption>
</figure>
<h6 id="components">Components</h6>
<figure>
<img src="images/Figure-06-Components-Class-Diagram-1.png"
alt="Components Class Diagram 1" />
<figcaption aria-hidden="true">Components Class Diagram 1</figcaption>
</figure>
<figure>
<img src="images/Figure-07-Components-Class-Diagram-2.png"
alt="Components Class Diagram 2" />
<figcaption aria-hidden="true">Components Class Diagram 2</figcaption>
</figure>
<h6 id="modules">Modules</h6>
<figure>
<img src="images/Figure-08-Modules-Class-Diagram.png"
alt="Modules Class Diagram 1" />
<figcaption aria-hidden="true">Modules Class Diagram 1</figcaption>
</figure>
<h6 id="platformprotection-domain">Platform/Protection domain</h6>
<figure>
<img src="images/Figure-09-Platform-PD-Class-Diagram-1.png"
alt="Platform PD Class Diagram 1" />
<figcaption aria-hidden="true">Platform PD Class Diagram 1</figcaption>
</figure>
<figure>
<img src="images/Figure-10-Platform-PD-Class-Diagram-2.png"
alt="Platform PD Class Diagram 2" />
<figcaption aria-hidden="true">Platform PD Class Diagram 2</figcaption>
</figure>
<h6 id="parsers">Parsers</h6>
<figure>
<img src="images/Figure-11-Parsers-Class-Diagram-1.png"
alt="Parsers Class Diagram 1" />
<figcaption aria-hidden="true">Parsers Class Diagram 1</figcaption>
</figure>
<figure>
<img src="images/Figure-12-Parsers-Class-Diagram-2.png"
alt="Parsers Class Diagram 2" />
<figcaption aria-hidden="true">Parsers Class Diagram 2</figcaption>
</figure>
<h4 id="asctg">1.4.2 ASCTG</h4>
<p>The ASCTG is a HARNESS generator allowing the creation of HARNESS
replacing all components that are not under test.</p>
<p>By this way the content of the user components can be tested
independently from the rest of the application implementation.</p>
<p>The HARNESS generation is composed of the following steps:</p>
<ul>
<li>Project’s XML files parsing and validation (using EXVT)</li>
<li>Parsing of ASCTG config file (containing components under test)</li>
<li>Generation of HARNESS files</li>
<li>Creation of HARNESS component type</li>
<li>Creation of HARNESS Component implementation file</li>
<li>Update of ECOA project file (to handle new HARNESS files)</li>
<li>Update of composite file (to add HARNESS component)</li>
<li>Update of deployment file (to add HARNESS protection domain)</li>
</ul>
<p>This generation leads to the following schema where A and B are the
components under test:</p>
<figure>
<img src="images/Figure-13-Harness-perimeter.png"
alt="HARNESS perimeter" />
<figcaption aria-hidden="true">HARNESS perimeter</figcaption>
</figure>
<p><strong>Class diagram</strong></p>
<figure>
<img src="images/Figure-14-ASCTG-Class-Diagram.svg"
alt="ASCTG Class Diagram" />
<figcaption aria-hidden="true">ASCTG Class Diagram</figcaption>
</figure>
<h4 id="ldp-generator">1.4.3 LDP generator</h4>
<p>The LDP tool is the ECOA application generator, it generates the
entire source code (framework level source code) and CMakeList files
required to compile and execute an ECOA application from an input ECOA
project file compliant with the ECOA AS 6 description.</p>
<p>The LDP generation process is composed of the following steps:</p>
<ul>
<li>Project XML files parsing and validation (using EXVT)</li>
<li>Building an internal ECOA model.</li>
<li>Generation of application C/C++ source files and CMakeList
files.</li>
</ul>
<p>For the generation, using information stored in the ECOA model, the
tool generates for each ECOA folder the corresponding source files and
its associated CMakeList file.</p>
<p>The tool also generates the CMakeList and the code of the ECOA
framework library used by the ECOA application.</p>
<p><strong>Class diagrams</strong></p>
<figure>
<img src="images/Figure-15-LDP-Class-Diagram.svg"
alt="LDP generator Class Diagram" />
<figcaption aria-hidden="true">LDP generator Class Diagram</figcaption>
</figure>
<h4 id="ecoa-toolset">1.4.4 ECOA-Toolset</h4>
<p>The ECOA-TOOLSET is a directory grouping common functions to parse
and generate an input ECOA project file. It builds an internal ECOA
model to generate skeleton source files for MSCIGT and a CSM for CSMGVT.
The ecoa-toolset generates types, headers templates and entry points
implementation.</p>
<h5 id="generator">1.4.4.1 Generator</h5>
<p>The generator directory groups all functions used to generate ECOA
module and container mechanisms (event, request-response, pinfo,
versioned data, time, logs), entry points, types.</p>
<p><strong>Types</strong></p>
<p>The types directory is used by CSMGVT and MSCIGT to generate, for a
given project, all the libraries and their data types sorted by
dependencies.</p>
<figure>
<img src="images/Figure-16-Toolset-Types-Class-Diagram.png"
alt="Toolset Types Class Diagram" />
<figcaption aria-hidden="true">Toolset Types Class Diagram</figcaption>
</figure>
<p><strong>Modules</strong></p>
<p>The module directory is used by MSCIGT to generate skeleton code in
module source files and function declarations in module header
files.</p>
<figure>
<img src="images/Figure-17-Toolset-Modules-Class-Diagram.png"
alt="Toolset Modules Class Diagram" />
<figcaption aria-hidden="true">Toolset Modules Class
Diagram</figcaption>
</figure>
<p><strong>Container</strong></p>
<p>The container directory is used by MSCIGT to generate function
declarations in container header files and skeleton code in container
mock files. It is also used by CSMGVT to generate implementation code in
the CSM file, a mock containing container code implementation.</p>
<figure>
<img src="images/Figure-18-Toolset-Container-Class-Diagram.svg"
alt="Toolset Container Class Diagram" />
<figcaption aria-hidden="true">Toolset Container Class
Diagram</figcaption>
</figure>
<p><strong>Helpers</strong></p>
<p>Helpers are functions that performs part of the computation of
another function following the DRY (Do not Repeat Yourself) concept. The
helper directory is used for the build of the CSM (CSMVT) and the module
unit tests (MSCIGT) to manipulate and handle the creation of: - Global
variable for the initialization of the module context and its ID, linked
mechanisms ID and functional aspect that needs it (platform hook, event,
request-response, versioned data, PINFO) - Platform hook, a platform
that handles module identification and mechanisms (properties, PINFO). -
Property values according to its type category.</p>
<figure>
<img src="images/Figure-19-Toolset-Helpers-Class-Diagram.png"
alt="Toolset Helpers Class Diagram" />
<figcaption aria-hidden="true">Toolset Helpers Class
Diagram</figcaption>
</figure>
<h5 id="models">1.4.4.2 Models</h5>
<ol type="1">
<li>ECOA XML Model</li>
</ol>
<p>The ecoa xml model python file contains the first class called to
parse an ECOA project xml. It stores each attribute of the xml in
corresponding directories that is used by the ecoa model python file.
This file uses the <code>ecoa_objects</code> directory to filter the
desired fields of each attribute.</p>
<p>Types:</p>
<figure>
<img src="images/Figure-20-Toolset-ECOA-Model-Class-Diagram.png"
alt="Toolset ECOA Model Class Diagram" />
<figcaption aria-hidden="true">Toolset ECOA Model Class
Diagram</figcaption>
</figure>
<p>Deployment, Final assembly:</p>
<figure>
<img
src="images/Figure-21-Toolset-Deploy-Final-Assembly-Class-Diagram.png"
alt="Toolset Deployment Final Assembly Class Diagram" />
<figcaption aria-hidden="true">Toolset Deployment Final Assembly Class
Diagram</figcaption>
</figure>
<ol start="2" type="1">
<li>ECOA Model</li>
</ol>
<p>The ecoa model python file is called to build an internal ECOA model
based on the ECOA XML model. The goal of this model is to facilitate the
manipulation of ECOA objects, by converting them, linking them when
necessary and finally rearranging them in dictionaries for an easier
access with a key system.</p>
<figure>
<img src="images/Figure-22-Toolset-ECOA-Model-2-Class-Diagram.svg"
alt="Toolset ECOA Model 2 Class Diagram" />
<figcaption aria-hidden="true">Toolset ECOA Model 2 Class
Diagram</figcaption>
</figure>
<ol start="3" type="1">
<li>Components</li>
</ol>
<p>Components are the base class of all ECOA operations. It allows the
building of Variables, Log, Time, Trigger, DynamicTrigger, Event,
Request-response, Versioned data, Property and PINFO objects. These
objects are used by the visitor design pattern as elements to visit.</p>
<p>Data:</p>
<p>The DataRead and DataWritten objects are constructed by the
DataParser and linked by the DataLinker.</p>
<p>A <code>DataRead</code> object has a dictionary called writers,
where:</p>
<ul>
<li>Each key is in the form
<code>#component_name#:#module_instance_name#</code>, where
<code>#component_name#</code> and <code>#module_instance_name#</code>
are respectively the name of the component and the name of the module
instance which can handle this DataRead object</li>
<li>Each value is another dictionary where:
<ul>
<li>Each key is in the form
<code>#component_name#:#module_instance_name#</code>, where
<code>#component_name#</code> and <code>#module_instance_name#</code>
are respectively the name of the component and the name of the module
instance manipulating which can handle a specific DataWritten
object</li>
<li>Each value corresponds to the handled DataWritten object</li>
</ul></li>
</ul>
<p>A <code>DataWritten</code> has a dictionary called readers which is
constructed according to the same logic.</p>
<p>These links made between readers and writers of a versioned data are
useful when generating the routing implementation in versioned data
container functions.</p>
<figure>
<img src="images/Figure-23-Toolset-Data-Class-Diagram.png"
alt="Toolset Data Class Diagram" />
<figcaption aria-hidden="true">Toolset Data Class Diagram</figcaption>
</figure>
<p>Event, Requests:</p>
<p>The EventSend, EventReceived, External, Trigger, DynamicTriggerSend
and DynamicTriggerReceived objects are constructed by the EventsParser
and linked by the EventsLinker. The RequestSend and RequestReceived
objects are constructed by the RequestsParser and linked by the
RequestsLinker.</p>
<p>These event and request objects have dictionaries (senders and
receivers) constructed with the same logic as writers and readers
dictionaries for data objects. These links made between senders and
receivers are again useful when generating the routing implementation in
event container functions and request-response container functions.</p>
<figure>
<img src="images/Figure-24-Toolset-Event-RR-Class-Diagram.png"
alt="Toolset Event RR Class Diagram" />
<figcaption aria-hidden="true">Toolset Event RR Class
Diagram</figcaption>
</figure>
<p>Log, Time, Variable, Property, PINFO:</p>
<p>The Log and Time objects are constructed by the ModuleParser. The
PINFO object are constructed by the PinfosParser. The Property objects
are constructed by the PropertiesParser and checked by the
PropertiesChecker.</p>
<figure>
<img
src="images/Figure-25-Toolset-Log-Time-Var-Property-Pinfo-Class-Diagram.png"
alt="Toolset Log Time Var Property PINFO Class Diagram" />
<figcaption aria-hidden="true">Toolset Log Time Var Property PINFO Class
Diagram</figcaption>
</figure>
<ol start="4" type="1">
<li>Helpers</li>
</ol>
<ul>
<li>Helpers are functions that performs part of the computation of
another function following the DRY (Don’t Repeat Yourself) concept. The
helper directory is used to search:</li>
<li>A list of modules with some characteristics
(<code>fault_handler</code>, <code>warm_start_context</code>).</li>
<li>A list of ECOA model services comment according to its category
(data, request-response, event).</li>
<li>A dictionary of types according to its category (Array, constant,
enum, fixedArray, simple, record, variantRecord, union) and build a
namespace for a type.</li>
</ul>
<figure>
<img src="images/Figure-26-Toolset-Helpers-Class-Diagram.png"
alt="Toolset Helpers Class Diagram" />
<figcaption aria-hidden="true">Toolset Helpers Class
Diagram</figcaption>
</figure>
<ol start="5" type="1">
<li>Visitors</li>
</ol>
<p>Visitors are a behavioral design pattern that allows to separate the
algorithm from an object structure on which it operates.</p>
<p>It helps to add new features to an existing class hierarchy
dynamically without changing it. Visitors are a way to handle
communication between objects and work very well on recursive structures
like trees or XML structures.</p>
<p>A Visitor method consist of two parts:</p>
<ul>
<li>A method named as visit() implemented by the visitor and used and
called for every element of the data structure.</li>
<li>A visitable class providing an accept() methods that accept a
visitor</li>
</ul>
<p>The following diagram illustrates the abstract visitor which sees his
methods implemented by concrete visitors, which are themselves used by
generators.</p>
<p>Concrete elements that implement the acceptance method are the
components (see above).</p>
<figure>
<img src="images/Figure-27-Toolset-Visitors-Class-Diagram.svg"
alt="Toolset Visitors Class Diagram" />
<figcaption aria-hidden="true">Toolset Visitors Class
Diagram</figcaption>
</figure>
<h4 id="mscigt">1.4.5 MSCIGT</h4>
<p>The MSCIGT generator generates the skeleton code of an ECOA
application, described via an input ECOA project file.</p>
<p>The MSCIGT generation process is composed of the following steps:</p>
<ul>
<li>Project’s XML files parsing and validation (using EXVT)</li>
<li>Building an internal ECOA model (ecoa-toolset).</li>
<li>Generation of skeleton C/C++ source and unit tests files.</li>
</ul>
<p>For the generation, using information stored in the ECOA model, the
tool generates for each ECOA folder the corresponding source files and
its associated unit tests.</p>
<p>The tool also generates the CMakeList for unit tests.</p>
<figure>
<img src="images/Figure-28-MSCIGT-Class-Diagram.svg"
alt="MSCIGT Class Diagram" />
<figcaption aria-hidden="true">MSCIGT Class Diagram</figcaption>
</figure>
<h4 id="csmgvt">1.4.6 CSMGVT</h4>
<p>The CSMGVT tool is used to generate a CSM, a test environment without
the ECOA middleware and the real time problem.</p>
<p>It generates the container code and CMakeList files required to
compile and execute an ECOA application from an input ECOA project file
compliant with the ECOA AS 6 description.</p>
<p>The CSMGVT generation process is composed of the following steps:</p>
<ul>
<li>Project’s XML files parsing and validation (using EXVT)</li>
<li>Building an internal ECOA model (ecoa-toolset).</li>
<li>Generation of a C/C++ CSM, a functional test environnement without
the ECOA middleware and without real time problem, and CMakeList
files.</li>
</ul>
<p>For the generation, using information stored in the ECOA model, the
tool generates an application mock of the ECOA framework and for each
ECOA its associated CMakeList file.</p>
<figure>
<img src="images/Figure-29-CSMGVT-Class-Diagram.svg"
alt="CSMGVT Class Diagram" />
<figcaption aria-hidden="true">CSMGVT Class Diagram</figcaption>
</figure>
<h2 id="software-toolkit-architecture-between-parts">2. Software toolkit
architecture between parts</h2>
<h3 id="description-of-dataflow-between-tool-parts">2.1 Description of
dataflow between tool parts</h3>
<figure>
<img src="images/Figure-30-Dataflow-between-parts-schema.png"
alt="Dataflow between parts schema" />
<figcaption aria-hidden="true">Dataflow between parts
schema</figcaption>
</figure>
<p>The workflow shows the link between tools. Each tools are connected
but independent and must be run by the user. The tool can be run in a
command line or with the help of an IHM in the <code>ecoa_ihm</code>
folder. An ECOA xml project is mandatory to run each tools. Relative or
an absolute path can be given.</p>
<h3 id="description-of-the-execution-principles-of-the-parts">2.2
Description of the execution principles of the parts</h3>
<h4 id="mscigt-allowing-unit-test-execution">2.2.1 MSCIGT (allowing unit
test execution)</h4>
<p>When MSCIGT is run, the tool generates skeleton code source and for
each modules, a unit tests folder. This folder is composed of a:</p>
<ul>
<li><code>Cmakelists.txt</code> file, to build the unit test.</li>
<li><code>main.c</code> file, to run the lifecycle of modules
instance.</li>
<li><code>module_container_mock.c</code> file, a mock similar to a CSM
to create a test environment without the ECOA middleware and real time
problem.</li>
</ul>
<h4 id="csmgvt-allowing-csm-execution">2.2.2 CSMGVT (allowing CSM
execution)</h4>
<p>When CSMGVT is run, the tool generates a CSM file. This folder is
composed of a:</p>
<ul>
<li><code>Cmakelist</code> file, to build the CSM.</li>
<li><code>main.cpp</code> file, to run the lifecycle of modules
instance.</li>
<li><code>CSM_project_name.cpp</code>, the mock container to create a
test environment without the ECOA middleware and real time problem.</li>
<li>Module folders with a Cmakelist to create library modules.</li>
</ul>
<p><strong>Module details</strong></p>
<p>Each ECOA Module Instance (Trigger, or Dynamic Trigger) are
sequentially executed, meaning that the notions of time and parallelism
do not exist. An ECOA Module Instance is defined by a context that
contains among others:</p>
<ul>
<li>A platform hook to handle technical datas (ID, properties,
pinfos)</li>
<li>A user context.</li>
<li>A warm start context</li>
</ul>
<p>All ECOA Module instance has at least 4 entry points for lifecycle
operations: INITIALIZE, START, STOP and SHUTDOWN.</p>
<p><strong>Communication</strong></p>
<p>Communication managed in the CSM are exchanges between modules within
the same component, and exchanges between modules from different
components.</p>
<p><strong>Starting ECOA modules</strong></p>
<p>The main code consists in the following sequence:</p>
<ul>
<li>To initialize global variables in the CSM (platform hook, opening
pinfo files).</li>
<li>To initialize all modules</li>
<li>To start all modules</li>
<li>To activate triggers</li>
<li>To stop all modules</li>
<li>To shutdown all modules</li>
<li>To shutdown global variables (opened file for pinfos)</li>
</ul>
<p>The main file mocks the ECOA framework by using an infinite loop to
call the entry points linked to the activation of modules.</p>
<p><strong>Versioned data</strong></p>
<p>The versioned data is represented by a two global variables in the
CSM:</p>
<ul>
<li>Data global variable</li>
<li>Stamp global variable</li>
</ul>
<p>Those global variables can be managed by three mechanisms:</p>
<ul>
<li><strong>Get_read</strong>: this function copy the data of the global
variable (data and stamp) in the <code>data_handle</code> given by the
user when the function is called in the main.</li>
<li><strong>Get_write</strong>: this function works in two times, an
initialization part of the <code>data_handle</code> given by the user if
this is the first time the versioned data is called, and a write part
where the data and stamp global variables are stored in the
<code>data_handle</code> given by the user.</li>
<li><strong>Publish_write</strong>: this function is used to update the
values in the <code>data_handle</code> given by the user in the data
global variable.</li>
</ul>
<p><strong>Pinfo</strong></p>
<p>Pinfos are managed via the platform hook by a global structure named
<code>pinfo_struct</code> in the CSM. This structure is built with:</p>
<ul>
<li><code>Pinfo_index</code>: the position of the cursor in the
file.</li>
<li><code>Pinfo_size</code>: the size of the file to read.</li>
<li><code>Pinfo_file</code>: the pinfo file.</li>
</ul>
<p>All variables in this structure are initialized to 0 by default in
the CSM.</p>
<p>The <code>pinfo_file</code> is initialized according to the parameter
file defined in the <code>csm_initialize</code> function, which is
called from the main.</p>
<p>There are two operations to manage pinfos:</p>
<ul>
<li><strong>Read pinfo</strong>: this function read the number of bytes,
store it in the <code>memory_address</code> given by the user and store
the number of bytes read in the <code>out_size</code> variable.</li>
<li><strong>Seek pinfo</strong>: this function places the cursor, store
in the <code>new_position</code>, using the whence and offset given by
the user.</li>
</ul>
<h4 id="ldp">2.2.2 LDP</h4>
<h5 id="ldp-platform-architecture">2.2.2.1 LDP platform
architecture</h5>
<h6 id="global-architecture-1">2.2.2.1.1 Global Architecture</h6>
<p>LDP Platform is a multi-processed and multi-threaded application. The
entry point of an LDP Platform is the main process that: - Starts other
processes (Protection Domain) - Synchronizes the start of ECOA modules -
Detects child process failure - Manages ELI starting sequence</p>
<p>In LDP Platform: - A Module Instance is an independent thread but can
be optionally set to run with other modules on the same thread (see
Optional Module Mapping). - A Protection Domain is an independent
process that contains: - A thread that reads sockets and routes messages
to Deployed Module Instance (the router-thread). - A thread for each
Deployed Module Instance or, if the option is activated, multiple Module
Instances from different Components. - Some Modules could need other
threads (i.e., Trigger Module, Module that sends Asynchronous Request
Response, …)</p>
<p>Note: LDP Platform is based on POSIX threads (also known as pthread)
for thread management and scheduling.</p>
<p>Note: Currently, all modules of a given component must be deployed in
the same Protection Domain.</p>
<figure>
<img src="images/Figure-31-LDP-platform-holding-3-cp-in-2-PD.png"
alt="LDP high level architecture" />
<figcaption aria-hidden="true">LDP high level architecture</figcaption>
</figure>
<h6 id="hardware-characteristics">2.2.2.1.2 Hardware
characteristics</h6>
<p>LDP is designed to be compliant with most of up-to-date PC hardware
configurations. See TOR for minimal hardware requirements.</p>
<h6 id="protection-domain-details">2.2.2.1.3 Protection Domain
details</h6>
<p>A Protection Domain is defined by a router thread and a context. The
context is a structure containing among others:</p>
<ul>
<li>The Protection Domain state. It is used at startup to synchronize
the start of modules across all LDP Platform</li>
<li>A structure to save information about Versioned Data operations</li>
<li>A Logger for technical messages.</li>
<li>Contexts of all Modules Instance (Normal, Trigger, Dynamic
Trigger)</li>
<li>Structures to manage socket connections</li>
</ul>
<p>The router thread manages the creation and the connection of sockets,
the creation and the start of modules, the creation of Versioned Data
Repository. It is also responsible for routing messages concerning
modules to the right modules. The other messages should be consumed by
the router-thread (Versioned Data updates, platform messages).</p>
<figure>
<img src="images/Figure-32-LDP-PD-structure.png"
alt="LDP Protection Domain Structure" />
<figcaption aria-hidden="true">LDP Protection Domain
Structure</figcaption>
</figure>
<h6 id="module-details">2.2.2.1.4 Module details</h6>
<p><strong>ECOA Module</strong></p>
<p>Each ECOA Module Instance (Normal, Trigger, or Dynamic Trigger) is
either in an independent thread or group with other ECOA Modules (see
Optional Module Mapping) and passively waits for a POSIX condition as
long as its message FIFO is empty or without activating operations.</p>
<p>An ECOA Module Instance is defined by a context that contains among
others:</p>
<ul>
<li>The state of the module used for ECOA lifecycle</li>
<li>A logger for module log messages.</li>
<li>A FIFO manager that contains the FIFO. The FIFO contains pending
messages that are consumed sequentially by the module thread following
ECOA rules (see: FIFO manager).</li>
<li>A structure named <code>operation_map</code> that contains
information for operations that can be by the Module Instance.</li>
<li>A buffer which contains message to send on socket or to read from
socket.</li>
<li>Module thread ID (unique on ECOA platform)</li>
</ul>
<p>All ECOA Module instance has at least 4 entry points for lifecycle
operations: INITIALIZE, START, STOP and SHUTDOWN.</p>
<p><strong>Normal Module</strong></p>
<p>The context of Normal Module contains also:</p>
<ul>
<li>Properties structures that contain property values</li>
<li>A structure that manages received or sent Request-Response</li>
<li>A thread to manage outdated asynchronous Request-Response</li>
<li>A structure that manages Versioned Data in read access</li>
<li>A structure that manages Versioned Data in write access</li>
</ul>
<figure>
<img src="images/Figure-33-LDP-Normal-Module-structure.png"
alt="LDP Normal Module Structure" />
<figcaption aria-hidden="true">LDP Normal Module Structure</figcaption>
</figure>
<p><strong>Trigger Module</strong></p>
<p>In addition to an ECOA Module’s context, the Trigger Module’s context
contains a structure that contains information about different periods
and events to send.</p>
<p>Trigger Module has a special structure to handle multiple frequencies
and to send events to multiple modules or interfaces (outside
component). Like a normal module, a trigger module has a FIFO and a main
thread that reads sequentially messages from FIFO. A Trigger Module has
only the 4 entry points operations which are the lifecycle
operations.</p>
<p>For each different period, Trigger Module creates: - A POSIX timer
controlled by the module main thread (start and stop) - A thread
receiving signals from the POSIX timer in order to send events.</p>
<figure>
<img src="images/Figure-34-LDP-Trigger-Module-structure.png"
alt="LDP Trigger Module Structure" />
<figcaption aria-hidden="true">LDP Trigger Module Structure</figcaption>
</figure>
<p><strong>Dynamic Trigger Module</strong></p>
<p>The context of a Dynamic Trigger Module contains, in addition to the
ECOA Module context:</p>
<ul>
<li>A structure that contains information about different delays to wait
and events to send.</li>
<li>Minimal and maximal values of delays.</li>
</ul>
<p>Dynamic Trigger Module has a special structure. It contains a FIFO
and a module main thread.</p>
<p>In addition to the lifecycle operations, the module can receive “set”
and “reset” operations.</p>
<p>To handle these 2 specific operations, dynamic Trigger Module has a
second thread.</p>
<p>Its role is to compute the date of the next wakeup. This date is
updated when a wakeup happens or when a “set” operation is received.</p>
<p>When a wakeup happens, the special thread sends events to connected
modules or interfaces.</p>
<figure>
<img src="images/Figure-35-LDP-Dynamic-Trigger-structure.png"
alt="LDP Dynamic Trigger Structure" />
<figcaption aria-hidden="true">LDP Dynamic Trigger
Structure</figcaption>
</figure>
<h5 id="ldp-inter-processes-communication">2.2.2.2 LDP Inter-processes
communication</h5>
<p>All communications between processes are made with TCP or UDP
networking protocol. Consequently, ECOA messages between 2 modules in 2
different Protection Domains are sent with TCP/UDP. Messages between the
main process and Protection Domain processes are also sent with
TCP/UDP.</p>
<p>The main process is connected with all child processes (all
Protection Domains). Protection Domains are connected with some
Protection Domains regarding wires described in XML files: one wire
between two Components in different Protection Domain is represented by
one IP connection.</p>
<p>The implementation of the Main-process and the router-thread for TCP
or UDP have a lot of differences. For TCP, a mechanism for connection
and reconnection is implemented. That is useless for UDP (UDP is
connectionless). The functions prototypes for inter-process
communication are the same for TCP or UDP protocol but the
implementation is completely different.</p>
<p>Note: The choice of the protocol is made at compilation. Only the
used source files will be compiled.</p>
<figure>
<img src="images/Figure-36-Inter-processes-communication-Diagram.png"
alt="LDP Inter-processes Communication diagram" />
<figcaption aria-hidden="true">LDP Inter-processes Communication
diagram</figcaption>
</figure>
<p>The figure above displays three protection domains. The wires
represent the IP communication between each of them. Protection domain 2
represents a dedicated thread executing multiple grouped modules (see
Optional Module Mapping). Those grouped modules can be from the same or
different components. Modules from the same Protection Domain are not
communicating through IP connection.</p>
<h6 id="application-network-frame">2.2.2.2.1 Application network
frame</h6>
<p>Frame of a message between two processes always starts by a flag of 4
bytes (0xECOA). By this way, it is possible to detect and correct read
error on sockets. Currently, only error detection is implemented. Every
message is constructed as below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">16</th>
<th style="text-align: center;">32</th>
<th style="text-align: center;">64</th>
<th style="text-align: center;">96</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0xE</td>
<td style="text-align: center;">0xC</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">0xA</td>
<td style="text-align: center;">Parameter size</td>
<td style="text-align: center;">Operation ID</td>
<td style="text-align: center;">Parameters</td>
</tr>
</tbody>
</table>
<p>For Request-response messages, a sequence number is added before the
message. This number is used to retrieve the sender module and route the
response to it.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">16</th>
<th style="text-align: center;">32</th>
<th style="text-align: center;">64</th>
<th style="text-align: center;">96</th>
<th style="text-align: left;">128</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0xE</td>
<td style="text-align: center;">0xC</td>
<td style="text-align: center;">0x0</td>
<td style="text-align: center;">0xA</td>
<td style="text-align: center;">Sequence number</td>
<td style="text-align: center;">Parameter size</td>
<td style="text-align: center;">Operation ID</td>
<td style="text-align: left;">Parameters</td>
</tr>
</tbody>
</table>
<p>With TCP protocol, the message is sent without specific application
header knowing that the protocol guarantees the arrival of the complete
message. With UDP protocol, it is necessary to cut long message in
several packets and to add a header on each packet to enable the
receiver to re-build the message. (More details in §UDP)</p>
<p>Note: for communication inside a Platform (i.e.: not for ELI),
messages are not serialized. Consequently, sender and receiver must have
the same Endianness property.</p>
<p>It could be a problem if sender and receiver are not on the same
physical computer.</p>
<h6 id="tcp">2.2.2.2.2 TCP</h6>
<p>With the TCP protocol, the server-side is the Protection Domain with
the Component that provides services, and the client-side is the other
one.</p>
<p>A TCP connection has a specific port. On server-side, the server has
a connection socket that is used only to (re-)connect with client. The
communication is made on the communication socket. The client has only a
communication socket.</p>
<figure>
<img src="images/Figure-37-LDP-Example-of-TCP-com.png"
alt="LDP Example of TCP communication" />
<figcaption aria-hidden="true">LDP Example of TCP
communication</figcaption>
</figure>
<p>The previous figure shows a simple example with 2 components in 2
different Protection Domains. The 2 components are connected by one
wire. This wire is implemented as a TCP connection on the port C.</p>
<p><strong>Connection/Reconnection behavior</strong></p>
<p>The main process and the router-threads have the same structure. But
the main process is more specific.</p>
<p>The router function listens for incoming messages on a list of
sockets, reads these messages and routes messages to FIFO module or
consumes them if they are platform messages.</p>
<p>To listen socket, router and main processes use a poll of file
descriptors. At the start of the router-thread, the connection with the
main process is already established.</p>
<p>Connections with other Protection Domains need to be established:</p>
<ul>
<li>For server connections, server sockets are created and listen for a
new connection. Server sockets are added to the poll of file
descriptor.</li>
<li>For client connections, a list of unconnected interfaces contains
all the connections to establish with a server. The router-thread tries
to establish every connection and removes the interface from the list of
unconnected interfaces when the connection is established.</li>
</ul>
<p>When a connection is established, the communication socket is added
to the poll of file descriptor.</p>
<p>The router thread or main process starts to listen to the poll of
file descriptors. In case of event on a file descriptor, it could
be:</p>
<ul>
<li>A new connection if it is a connection socket: in this case, the
client is accepted; a communication socket is created, and a file
descriptor is added to the poll.</li>
<li>A message on a socket: the message is read and routed.</li>
<li>A closed socket event: attached file descriptor is removed.
<ul>
<li>If it is a client disconnection, the communication socket is
removed.</li>
<li>If it is a server disconnection, the interface is added to the list
of unconnected interfaces.</li>
<li>Periodically, router thread tries to reconnect interface with
server.</li>
</ul></li>
</ul>
<h6 id="udp">2.2.2.2.3 UDP</h6>
<p>In UDP, there is no need of connection between sockets. Unlike TCP,
an UDP link is symmetrical. It is much simpler: there is neither client
nor server. A “UDP interface” is composed of a read socket and a write
socket.</p>
<figure>
<img src="images/Figure-38-LDP-UDP-connection.png"
alt="LDP UDP connection" />
<figcaption aria-hidden="true">LDP UDP connection</figcaption>
</figure>
<p><strong>Send on a UDP socket</strong></p>
<p>To send messages on UDP socket, messages should not be too big. Big
messages are fragmented in packets. Packets are sent on the socket and
the receiver needs to re-build the completed messages thanks to
information in the packet header. The header of an UDP packet is
composed of:</p>
<ul>
<li>An ID of message to make a difference between packets from different
messages. ID is an increased number. It could be used to compare ages of
2 messages.</li>
<li>The byte number in the completed message the start of the data. It
is used to reconstruct completed message if packets arrive
disorderly.</li>
<li>The size of data</li>
<li>The number of packets that should be received to completed
message</li>
</ul>
<figure>
<img src="images/Figure-39-LDP-UDP-packets.png" alt="LDP UDP Packets" />
<figcaption aria-hidden="true">LDP UDP Packets</figcaption>
</figure>
<figure>
<img src="images/Figure-40-LDP-UDP-message-emission.png"
alt="LDP UDP Message Emission" />
<figcaption aria-hidden="true">LDP UDP Message Emission</figcaption>
</figure>
<p><strong>Read on a UDP socket</strong></p>
<p>The read must re-build message and reorder received packets.
Currently, the receiver can wait only for one uncompleted message at a
time and accepts only the most recent message.</p>
<ul>
<li>All packets with the same ID are saved in a buffer and reordered
when all packets from a same message identifier are received.</li>
<li>When a packet with a greater ID arrives / is received, the previous
packets are discarded (the current uncompleted message becomes
obsolete).</li>
<li>When a packet with a lower ID (lower than the current processed
message) is received, the packet is discarded (packet is too old).</li>
</ul>
<p>Consequently, the loss of one packet leads to the removal of the
incomplete message. Congestion on the read socket can lead to the loss
of a lot of messages. There is no mechanism allowing the resent of a
lost packet.</p>
<figure>
<img src="images/Figure-41-LDP-UDP-message-reception.png"
alt="LDP UDP Message Reception" />
<figcaption aria-hidden="true">LDP UDP Message Reception</figcaption>
</figure>
<h5 id="ldp-platform-startup">2.2.2.3 LDP Platform startup</h5>
<h6 id="platform-creation-and-establishing-connections">2.2.2.3.1
Platform creation and establishing connections</h6>
<p>At platform startup, the main process creates sockets and starts
other processes. Then it waits for new connections.</p>
<h6 id="protection-domain-router-thread-details">2.2.2.3.2 Protection
Domain router thread details</h6>
<p>The router thread is the main thread of a Protection Domain
process.</p>
<p>It is started at the beginning to create Module threads and make
TCP/UDP connections.</p>
<p>But after the start of a platform, its role is to route messages from
sockets to Module FIFO and to make TCP reconnection.</p>
<p>At startup, the router thread aims at:</p>
<ul>
<li>Creating component context which contains module contexts.</li>
<li>Initializing data structure (like logger, external Versioned Data
manager)</li>
<li>Creating module threads</li>
<li>Creating sockets</li>
<li>Start router function</li>
</ul>
<p>At last, the router server is started.</p>
<h6 id="starting-ecoa-modules">2.2.2.3.3 Starting ECOA modules</h6>
<p>When the main process has received notification from all the
Protections Domains that servers’ threads are running.</p>
<p>The main server notifies router-threads to initialize all
modules.</p>
<p>Route-threads send INITIALIZE events to all modules regarding ECOA
order: Trigger modules, dynamic trigger modules, and then other
modules.</p>
<p>The last module of a Protection Domain that finishes to consume these
events notify the main process.</p>
<p>The main process received notification from all Protection Domains
that all modules are in READY state. Then the main process notifies
router-threads to start all modules. Router-threads send START to all
modules regarding ECOA order. Then module threads consume this event and
change module state to RUNNING.</p>
<figure>
<img src="images/Figure-42-LDP-Steps-to-start-PD.png"
alt="LDP Steps to start PD" />
<figcaption aria-hidden="true">LDP Steps to start PD</figcaption>
</figure>
<figure>
<img src="images/Figure-43-LDP-Steps-to-start-Platform.png"
alt="LDP Steps to start Platform" />
<figcaption aria-hidden="true">LDP Steps to start Platform</figcaption>
</figure>
<h5 id="ldp-module-operations">2.2.2.4 LDP Module operations</h5>
<h6 id="send-operation">2.2.2.4.1 Send Operation</h6>
<p><strong>Operation Map</strong></p>
<p>When an ECOA module calls a function in its container to send an
operation (event, request-response or versioned data), the function uses
an <code>operation_map</code> structure to retrieve receiver information
for this operation. An operation map contains:</p>
<ul>
<li>The list of local module contexts which receive this operation</li>
<li>The list of sockets (in platform) which send message to other
protection domains</li>
<li>The list of ELI socket which send message to other ECOA
platform</li>
</ul>
<p>For each receiver modules, some information is necessary:</p>
<ul>
<li>The operation ID in the receiver module,</li>
<li>The operation index to find the element pool (see FIFO manager)
which handle operation.</li>
<li>Information about activating property of this operation</li>
<li>Information about the answer of this operation for Asynchronous
Request-Response only</li>
</ul>
<p>For each socket (ELI or not), same information is necessary except
the activating property of the operation. This information is known by
the router of the receiver Protection Domain.</p>
<p><strong>Sending Message</strong></p>
<p>To send an operation, module container uses <code>msg_buffer</code>
to write parameters. For local message (local receiver modules and same
platform sockets), parameters are not serialized. They are just copied
in buffer with the right index.</p>
<p>For socket messages, a header is added (see §network frame).</p>
<p>For ELI message between Platforms, the ELI header is added at the
beginning of the message.</p>
<p>For local module receiver, operation is directly push in FIFO using
FIFO manager of the receiver.</p>
<p><strong>Send an Event Operation</strong></p>
<p>Event operation are broadcast to every receiver module, local sockets
and ELI sockets of the operation map.</p>
<p><strong>Send Request-Response</strong></p>
<p>For a Request-Response, if the operation map has more than one
receiver, the request is sent only one time to the first receiver in
this order:</p>
<ul>
<li>first local module</li>
<li>first local socket</li>
<li>first ELI socket</li>
</ul>
<p>To send a Request Response, module container has to:</p>
<ul>
<li>Check if the maximum number of concurrent operations is not reached
for this operation</li>
<li>Save information about the sent request in
<code>request_response</code> structure</li>
</ul>
<figure>
<img src="images/Figure-44-LDP-Save-info-about-RR.png"
alt="LDP Parameters in RR structure" />
<figcaption aria-hidden="true">LDP Parameters in RR
structure</figcaption>
</figure>
<ul>
<li>For asynchronous Request-Response: set trigger to retrieved timeout
Request-Response</li>
<li>If server is a module:
<ul>
<li>Save information about the <code>request_received</code> in
<code>request_response</code> structure of the server module</li>
<li>push message in FIFO module, copy parameter</li>
</ul></li>
<li>If server is socket: send message with <code>sequence_number</code>
(= ID of the sender module)
<ul>
<li>If server is an ELI socket, <code>sequence_number</code> and
parameter must be serialized before sending.</li>
</ul></li>
</ul>
<p>In case of synchronous Request-Response, client module waits on a
thread condition (with a timeout).</p>
<p>The client is unlocked by either an answer or a timeout. When the
condition is satisfied without being triggered by the timeout, the
answer will be located on the top of the FIFO.</p>
<p>For asynchronous Request-Response, a special thread can push invalid
answers to client FIFO in case of timeout.</p>
<figure>
<img src="images/Figure-45-LDP-RR-structure.png"
alt="LDP RR Structure" />
<figcaption aria-hidden="true">LDP RR Structure</figcaption>
</figure>
<p><strong>Send Request-Response answer</strong></p>
<p>For a response of a Request-Response, the sender is retrieved thanks
to information saved in the <code>request_received</code> structure
(created when the request has been received). The sender could be a
module, a local socket or an ELI socket.</p>
<p>For module, answer is pushed directly in the FIFO manager. For
synchronous answer, the operation is pushed in the first place and the
receiver module is unlocked by sending signal with the POSIX
condition.</p>
<p>For socket, Header and <code>sequence_number</code> are added to the
message before sending.</p>
<p>For ELI socket, information must be serialized.</p>
<h6 id="fifo-manager">2.2.2.4.2 FIFO Manager</h6>
<p>The FIFO manager is an abstract structure to push and pop elements
to/from a module FIFO. It contains structures to handle operations and
parameters. FIFO manager controls the maximum number of operation that a
FIFO can contain. The FIFO manager authorizes or not module to pop an
element from FIFO according to the number of activating operations in
FIFO.</p>
<p>A FIFO manager is composed of:</p>
<ul>
<li>A FIFO</li>
<li>A mutex to protect concurrent accesses</li>
<li>A thread condition to block/unblock the module thread if it tries to
pop an element operation</li>
<li>An Integer that represents the current number of pending activating
operations in FIFO</li>
<li>An array of element pool that contains FIFO element for each type of
operation. The pool with index 0 is reserved for platform and lifecycle
operations. The other pools are created regarding the possible operation
that the module can received: one pool for each type of operation. In
each pool, elements are sized to handle parameters of operation</li>
</ul>
<figure>
<img src="images/Figure-46-LDP-FIFO-Manager-structure.png"
alt="LDP FIFO Manager Structure" />
<figcaption aria-hidden="true">LDP FIFO Manager Structure</figcaption>
</figure>
<p><strong>Pushing elements in FIFO</strong></p>
<p>A Module A (or the router thread) wants to push an operation
<strong>op_C</strong> in the FIFO of a Module B of the same component.
To push an element, the Module A (or router thread) needs to know:</p>
<ul>
<li>The index of the operation <strong>op_C</strong> in the FIFO manager
of the module B to get the element pool.</li>
<li>The operation ID of <strong>op_C</strong> in Module B</li>
<li>If the operation is activating or not-activating</li>
</ul>
<p>Module A gets an element from the right pool. The get operation is
thread-safe. The element is tagged as “USED” to enable Module A writing
operation information inside (operation ID, activating operation,
parameters, and parameter size).</p>
<p>Then Module A pushes the element in FIFO (also thread-safe). The FIFO
manager:</p>
<ul>
<li>Push the new operation <strong>op_C</strong> in FIFO</li>
<li>Update the current number of pending activating operation. If this
number is greater than zero, the FIFO manager signals the Module B using
a POSIX signal to the thread condition.</li>
</ul>
<figure>
<img src="images/Figure-47-LDP-FIFO-Manager-push.png"
alt="LDP Example of FIFO Manager push" />
<figcaption aria-hidden="true">LDP Example of FIFO Manager
push</figcaption>
</figure>
<p>The previous figure shows an example of the FIFO Manager of module B
When <strong>op_C</strong> is pushed.</p>
<p><strong>Popping elements from FIFO</strong></p>
<p>The module B waits on a thread condition for the FIFO manager to
enable to pop element. When it is possible, Module B pops an element.
The FIFO manager updates the current number of activating operations
pending in FIFO (if it is an activating operation).</p>
<p>When Module B consumes popped element, the element is released in the
right element pool. It is tagged as “FREE”.</p>
<h6 id="driver-api">2.2.2.4.3 Driver API</h6>
<p>A non ECOA module can push Event operations in an ECOA Module using a
generated driver API.</p>
<p>To implement that, the component context of the target module is
saved as a global variable.</p>
<p>Functions in the Driver API can access the target FIFO module using
the global variable of component context.</p>
<p>Driver API function push operation directly in FIFO exactly like a
normal module.</p>
<h6 id="pinfo-manager">2.2.2.4.4 Pinfo manager</h6>
<p>In “Normal” Module context, a Pinfo manager is created. This
structure manages all accesses to Pinfo files that the Module can have.
A Pinfo manager structure contains:</p>
<ul>
<li>The number of Pinfo</li>
<li>An array of <code>Pinfo_structure</code> for each Pinfo handled by
the Module. <code>Pinfo_structure</code> contains:
<ul>
<li>The file name of the Pinfo (absolute path)</li>
<li>The stream</li>
</ul></li>
</ul>
<figure>
<img src="images/Figure-48-LDP-Pinfo-Manager.png"
alt="LDP Pinfo Manager" />
<figcaption aria-hidden="true">LDP Pinfo Manager</figcaption>
</figure>
<h6 id="versioned-data-repository">2.2.2.4.5 Versioned Data
repository</h6>
<p><strong>Architecture</strong></p>
<p>In a Protection Domain, if a module has an operation on Versioned
Data (read or written), the Protection Domain handle this Versioned Data
in a structure (Versioned Data Repository). This structure contains
among other:</p>
<ul>
<li>An array of copy of the Versioned Data</li>
<li>The list of the Readers of this Versioned Data that must be notified
or updated after publication of data</li>
<li>A pointer to the function that serializes a Versioned data in a
message which is sent outside the Platform.</li>
<li>A pointer to retrieve the last published Versioned Data in the array
of copy</li>
</ul>
<p>The design and the algorithm allow parallel reading or writing
without blocking on a memory copy operation.</p>
<p>Note: Due to the ECOA standard, Protection Domains must be isolated
in memory. Consequently, shared memory cannot be easily used to
implement Versioned Data.</p>
<p>Module container accesses the Versioned data repository as a Reader
or a Writer using specific manager:</p>
<ul>
<li>Reader manager contains read accesses as copy of the data</li>
<li>Writer manager contains write access as pointer to copy of data in
the repository structure</li>
</ul>
<p>Note: in the ECOA standard, Readers can locally modify a Versioned
Data. But the data in the repository must remain intact.</p>
<p>Thus, a read access to a Versioned Data is a copy of the data. To
avoid copying repository during a read access, the Reader could access
directly the last published Versioned Data.</p>
<p>But nothing could prevent the Reader from modifying the data.</p>
<figure>
<img src="images/Figure-49-LDP-Example-Data-state-repository.png"
alt="LDP Example of the state of a repository" />
<figcaption aria-hidden="true">LDP Example of the state of a
repository</figcaption>
</figure>
<p><strong>Publication and notification mechanism</strong></p>
<p>When a Writer has published data, it must notify local Readers
modules and updated data of external Readers. Those Readers can be:</p>
<ul>
<li>A local module (in the same Protection Domain) that should receive a
notification message.</li>
<li>Another repository (in the Protection Domain) that should be update
directly. The Writer writes the new data directly in the other
repository.</li>
<li>A local socket, if the Reader is in another Protection Domain on the
same Platform. The Writer sends messages containing the new data on the
socket.</li>
<li>An external socket connected with another Platform. The Writer sends
messages containing the new data on the socket using ELI protocol.</li>
</ul>
<p><strong>Optimization of repository number</strong></p>
<p>In some case, it is possible to reduce the number of Versioned Data
Repository in a Protection Domain. Some Versioned Data Repositories in
the same Protection Domain can be merged.</p>
<figure>
<img src="images/Figure-50-LDP-Example-merge-of-2-VD.png"
alt="LDP Example of merge of 2 VD" />
<figcaption aria-hidden="true">LDP Example of merge of 2 VD</figcaption>
</figure>
<h5 id="ldp-platform-logger">2.2.2.5 LDP Platform logger</h5>
<p>To log technical or ECOA messages, LDP Platform can either use:</p>
<ul>
<li>zlog. Messages are written in specific text files:
<ul>
<li>One file for logs of the main process</li>
<li>For each Protection domains:
<ul>
<li>One file for technical logs (i.e., from the platform)</li>
<li>One file for module logs (i.e., logs with ECOA module container
API)</li>
</ul></li>
</ul></li>
<li>LTTNG is a C/C++ Framework for Linux only. LTTNG writes user or
kernel logs that are written in CTF format. LDP platform uses LTTNG
daemon with a session named <strong>Session_ECOA</strong>.</li>
<li>Console is the standard output.</li>
</ul>
<p>It is possible to choose one solution at compilation by using a cmake
variable. Log messages are written using ECOA format in files.</p>
<h5 id="ldp-inter-platform-communication-eli">2.2.2.6 LDP Inter-platform
communication (ELI)</h5>
<p><strong>Implementation</strong></p>
<p>ELI communications are only available using the UDP binding describes
in the annex A of ECOA AS Part 6 ELI.</p>
<p>ELI messages are processed as inter-process messages but with special
header. ELI messages can be sent by any modules or router-thread.</p>
<p>ELI messages are received, routed, or consumed by the
router-thread.</p>
<p>Endianness is supported for ELI messages only (not for communication
inside a Platform).</p>
<p>Message data (payload and headers) is converted in network-byte-order
if necessary.</p>
<p>Note: A part of the ELI implementation has been written to be used as
a library by another platform.</p>
<p><strong>UDP network architecture</strong></p>
<p>ELI network architecture uses UDP sockets in multicast. A couple
multicast address and port represent an end of a Platform Link.</p>
<p>Those information come from the binding XML files.</p>
<p>The main process is connected to every Platform Links using two
sockets (one to read, one to write).</p>
<p>The main process manages the ELI startup sequence.</p>
<p>Router-thread of each Protection Domain is only connected to every
Platform Links that need to be connected regarding Component Wires.</p>
<p>Router-thread also has two sockets per Platform Links to read or to
write messages.</p>
<p>ELI messages work exactly like inter-process messages on the same
Platform but with an ELI header.</p>
<p>The router-thread reads ELI messages on read sockets. Then it checks
if messages are relevant for the Protection Domain and correct.</p>
<p>Finally, it routes ELI messages to the right module(s). Modules can
send ELI messages using the same sending sockets of the
router-thread.</p>
<ol type="1">
<li>UDP Channel ID</li>
</ol>
<p>As every module thread could send ELI messages, modules must use
different UDP channel ID.</p>
<p>Modules use their module ID. Router-thread uses its Protection Domain
ID. Main process uses a channel ID equals to zero.</p>
<p>Consequently, on a Platform:</p>
<ul>
<li>Protection Domain IDs and Module IDs must be unique.</li>
<li>The number of module and Protection Domains connected to the same
Platform Link cannot be greater than 255 (because the maximum number of
channels on a Platform Link is 256)</li>
</ul>
<figure>
<img src="images/Figure-51-LDP-Example-ELI-network-for-one-PF-link.png"
alt="LDP Example of ELI network architecture for one PF Link" />
<figcaption aria-hidden="true">LDP Example of ELI network architecture
for one PF Link</figcaption>
</figure>
<p>The previous figure shows an example of the ELI network architecture
for one Platform Link.</p>
<ol start="2" type="1">
<li>Useless Messages</li>
</ol>
<p>The ELI network architecture has been designed to be efficient by
avoiding centralizing the reception of messages in one instance.
Unfortunately, this design increases the rate of useless messages.
Because of multicast option, any message that is transmitted on a
Platform Link is received by all router-threads which are connected on
this Platform Link.</p>
<p>Moreover, if some Platform Links have the same binding, any
router-threads connected to one of these Platform Links receive all
messages that is transmitted on one of those Links.</p>
<p>Then, lots of messages are discarded at different levels:</p>
<ul>
<li>When UDP header is read, if the UDP Platform ID is unknown</li>
<li>When the ELI header is read, if the Platform ID is equal to the
current Platform ID</li>
<li>If the operation ID of the message is unknown in the Protection
Domain</li>
</ul>
<p><strong>Startup sequence</strong></p>
<p>The ELI startup sequence is made by the Main Process when all
connections in Protection Domains are created (i.e.: all Protection
Domains are in state READY).</p>
<p>Router-threads read messages about Versioned Data.</p>
<p>Router-threads also answer to Versioned Data pull request by sending
the last published Versioned Data to requesting Platform</p>
<h5 id="ldp-fault-handler">2.2.2.7 LDP Fault Handler</h5>
<p>The Fault Handler is a mechanism that allows the infrastructure to
raise errors detected at different levels (Component, Protection Domain,
Computing Platform).</p>
<p>That mechanism allows also recovery actions for errors detected at
Protection Domain level (SHUTDOWN and COLD RESTART).</p>
<p><strong>Overall schema</strong></p>
<p>LDP Fault Handler mechanism is illustrated hereafter: <img
src="images/Figure-52-LDP-FH-Mechanism.png"
alt="LDP FH Mechanism" /></p>
<p><strong>Error exchange</strong></p>
<p>The errors are sent to the main process using sockets.</p>
<p>When the Fault handler receives an error, it calls the error
notification function
(<code>&lt;platform_name&gt;__error_notification</code>).</p>
<p>The content of the error notification function is implemented by the
user. Within the given implementation, regarding the error type
received, the user can decide to either called a recovery action or do
nothing.</p>
<p>By default, the error notification function is initially empty,
therefore no recovery action is performed.</p>
<p><strong>Signal</strong></p>
<p>When a Protection Domain crashes, the corresponding signal is caught
by the main process.</p>
<p>The error notification function is then called, and its behavior is
identical to the error handling.</p>
<p><strong>Table of errors managed by the fault handler</strong></p>
<figure>
<img src="images/Figure-53-LDP-FH-Table-of-errors.png"
alt="Table of errors managed by LDP Fault Handler" />
<figcaption aria-hidden="true">Table of errors managed by LDP Fault
Handler</figcaption>
</figure>
<p><strong>Error notification API</strong></p>
<p>Source file:</p>
<p>The error notification source file path is:
<code>&lt;app_name&gt;/5-Integration/src/&lt;platform_name&gt;_fault_handler.c</code></p>
<p>It contains the implementation of the
<code>&lt;platform_name&gt;__error_notification</code> function
following the prototype given by ECOA standard:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">&lt;</span>platform_name<span class="op">&gt;</span>__error_notification <span class="op">(</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ldp_fault_handler_context<span class="op">*</span> context<span class="op">,</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ECOA__error_id error_id<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  ECOA__global_time timestamp<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  ECOA__asset_id asset_id<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  ECOA__asset_type asset_type<span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  ECOA__error_type error_type<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  ECOA__uint32 error_code<span class="op">)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">/* Implementation */</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The implementation of this function provides the way to define the
Fault Handler recovery policy dedicated to the application. Parameters
are detailed by ECOA standard.</p>
<p><code>Error_code</code>:</p>
<p>The error notification API provides an additional parameter:
error_code. This parameter is used to help determining where the error
has occurred.</p>
<p>For each occurrence of an <code>error_type</code> in the code, a
value of <code>error_code</code> is provided, so every time an
<code>error_type</code> trace is logged, it allows to identify where it
is coming from.</p>
<p>As an example, let’s look at the following log:</p>
<pre><code>&quot;1627467299,677227060&quot;:1:&quot;INFO&quot;:&quot;main_PD&quot;:&quot;main_node&quot;:&quot;[MAIN] Fault
Handler NOTIFICATION: [1627467299:677207363] error_id=0 asset_id=2
asset_type=0 error_type=0 error_code=15&quot;</code></pre>
<p>We can now determine that this error has an <code>error_type</code>
of <code>RESOURCE_NOT_AVAILABLE (id=0)</code> and is associated to
<code>error_code</code> <code>15</code>.</p>
<h2 id="description-of-the-error-management-principles">3.Description of
the error management principles</h2>
<ul>
<li>Detection of errors in tool launching command (wrong or missing
argument) with a dedicated message in the user console</li>
<li>Detection of errors during ECOA input model checking (EXVT displays
error messages in the user console)</li>
</ul>
<p>There are no other robustness treatments in tools implementation.</p>
<h2 id="software-quality-aspect-of-tool-parts">4. Software quality
aspect of tool parts</h2>
<h3 id="coding-rules">4.1 Coding rules</h3>
<p>PEP8 for Python</p>
<p>Basic SonarQube set of rules for C and C++</p>
<h3 id="coverage-mode">4.2 Coverage mode</h3>
<p>The coverage mode can be enabled, in MSCIGT and CSMGVT, while the
compilation of the code and measures of how many lines, or blocks of
code are tested using a suite of automated tests.</p>
<p>The coverage is measured in percentage: the closer it is to 100%, the
better. The coverage mode will generate a <code>coverage.info</code>
file.</p>
<p><code>LCOV</code> is the tool used to have a graphical interface of
the coverage, it creates HTLM pages containing the source code annotated
with coverage information.</p>
<h3 id="profiling-mode">4.3 Profiling mode</h3>
<p>The profiling mode can be enabled in MSCIGT and CSMGVT in code
compiling directives.</p>
<p>Profiling allows to identify which parts of the code is slower in
execution than expected, and provide statistics through which many
potential bugs can be located and sorted out.</p>
<p>Once compiled, the code will produce a profiling data
<code>gmon.out</code>.</p>
<p><code>GPROF</code> is the tool used to run the executable with
<code>gmon.out</code> as an argument. It produces an analysis file which
contains all the desired profiling information.</p>
</body>
</html>
